// Code generated by candi v1.17.15.

package repository

import (
	"context"

	"strings"
	"time"

	"monorepo/services/library-service/internal/modules/book/domain"
	shareddomain "monorepo/services/library-service/pkg/shared/domain"

	"github.com/golangid/candi/candishared"
	"github.com/golangid/candi/tracer"

	"monorepo/globalshared"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type bookRepoSQL struct {
	readDB, writeDB *gorm.DB
	updateTools     *candishared.DBUpdateTools
}

// NewBookRepoSQL mongo repo constructor
func NewBookRepoSQL(readDB, writeDB *gorm.DB) BookRepository {
	return &bookRepoSQL{
		readDB: readDB, writeDB: writeDB,
		updateTools: &candishared.DBUpdateTools{
			KeyExtractorFunc: candishared.DBUpdateGORMExtractorKey, IgnoredFields: []string{"id"},
		},
	}
}

func (r *bookRepoSQL) FetchAll(ctx context.Context, filter *domain.FilterBook) (data []shareddomain.Book, err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "BookRepoSQL:FetchAll")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	if filter.OrderBy == "" {
		filter.OrderBy = "updated_at"
	}

	db := r.setFilterBook(globalshared.SetSpanToGorm(ctx, r.readDB), filter).Order(clause.OrderByColumn{
		Column: clause.Column{Name: filter.OrderBy},
		Desc:   strings.ToUpper(filter.Sort) == "DESC",
	})
	if filter.Limit > 0 || !filter.ShowAll {
		db = db.Limit(filter.Limit).Offset(filter.CalculateOffset())
	}
	err = db.Find(&data).Error
	return
}

func (r *bookRepoSQL) Count(ctx context.Context, filter *domain.FilterBook) (count int) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "BookRepoSQL:Count")
	defer trace.Finish()

	var total int64
	r.setFilterBook(globalshared.SetSpanToGorm(ctx, r.readDB), filter).Model(&shareddomain.Book{}).Count(&total)
	count = int(total)

	trace.Log("count", count)
	return
}

func (r *bookRepoSQL) Find(ctx context.Context, filter *domain.FilterBook) (result shareddomain.Book, err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "BookRepoSQL:Find")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	filter.Preloads = []string{"BookItems"}
	err = r.setFilterBook(globalshared.SetSpanToGorm(ctx, r.readDB), filter).First(&result).Error
	return
}

func (r *bookRepoSQL) SaveBook(ctx context.Context, data *shareddomain.Book, updateOptions ...candishared.DBUpdateOptionFunc) (err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "BookRepoSQL:Save")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	db := r.writeDB
	if tx, ok := candishared.GetValueFromContext(ctx, candishared.ContextKeySQLTransaction).(*gorm.DB); ok {
		db = tx
	}
	data.UpdatedAt = time.Now()
	if data.CreatedAt.IsZero() {
		data.CreatedAt = time.Now()
	}
	if data.ID == 0 {
		err = globalshared.SetSpanToGorm(ctx, db).Create(data).Error
	} else {
		err = globalshared.SetSpanToGorm(ctx, db).Model(data).Omit(clause.Associations).Updates(r.updateTools.ToMap(data, updateOptions...)).Error
	}
	return
}

func (r *bookRepoSQL) Delete(ctx context.Context, filter *domain.FilterBook) (err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "BookRepoSQL:Delete")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	db := r.writeDB
	if tx, ok := candishared.GetValueFromContext(ctx, candishared.ContextKeySQLTransaction).(*gorm.DB); ok {
		db = tx
	}
	err = r.setFilterBook(globalshared.SetSpanToGorm(ctx, db), filter).Delete(&shareddomain.Book{}).Error
	return
}

func (r *bookRepoSQL) setFilterBook(db *gorm.DB, filter *domain.FilterBook) *gorm.DB {

	if filter.ID != nil {
		db = db.Where("id = ?", *filter.ID)
	}
	if filter.Title != "" {
		db = db.Where("(title ILIKE '%%' || ? || '%%')", filter.Title)
	}
	if filter.Subject != "" {
		db = db.Where("(subject ILIKE '%%' || ? || '%%')", filter.Subject)
	}
	if filter.Publisher != "" {
		db = db.Where("(publisher ILIKE '%%' || ? || '%%')", filter.Publisher)
	}

	for _, preload := range filter.Preloads {
		db = db.Preload(preload)
	}

	return db
}

// Book Item
func (r *bookRepoSQL) FindItem(ctx context.Context, filter *domain.FilterBookItem) (result shareddomain.BookItem, err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "BookRepoSQL:Find")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	err = r.setFilterBookItem(globalshared.SetSpanToGorm(ctx, r.readDB), filter).First(&result).Error
	return
}

func (r *bookRepoSQL) SaveBookItem(ctx context.Context, data *shareddomain.BookItem, updateOptions ...candishared.DBUpdateOptionFunc) <- chan error {
	output := make(chan error)
	go tracer.WithTracerFunc(ctx, "BookRepoSQL:Save", func(ctx context.Context, _ tracer.Tracer) {
		db := r.writeDB
		if tx, ok := candishared.GetValueFromContext(ctx, candishared.ContextKeySQLTransaction).(*gorm.DB); ok {
			db = tx
		}
		data.UpdatedAt = time.Now()
		if data.CreatedAt.IsZero() {
			data.CreatedAt = time.Now()
		}
		if data.ID == 0 {
			output <-globalshared.SetSpanToGorm(ctx, db).Create(data).Error
		} else {
			output <-globalshared.SetSpanToGorm(ctx, db).Model(data).Omit(clause.Associations).Updates(r.updateTools.ToMap(data, updateOptions...)).Error
		}
	})

	return output

	// trace, ctx := tracer.StartTraceWithContext(ctx, "BookRepoSQL:Save")
	// defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	// db := r.writeDB
	// if tx, ok := candishared.GetValueFromContext(ctx, candishared.ContextKeySQLTransaction).(*gorm.DB); ok {
	// 	db = tx
	// }
	// data.UpdatedAt = time.Now()
	// if data.CreatedAt.IsZero() {
	// 	data.CreatedAt = time.Now()
	// }
	// if data.ID == 0 {
	// 	err = globalshared.SetSpanToGorm(ctx, db).Create(data).Error
	// } else {
	// 	err = globalshared.SetSpanToGorm(ctx, db).Model(data).Omit(clause.Associations).Updates(r.updateTools.ToMap(data, updateOptions...)).Error
	// }
	// return
}

func (r *bookRepoSQL) DeleteItem(ctx context.Context, filter *domain.FilterBookItem) (err error) {
	trace, ctx := tracer.StartTraceWithContext(ctx, "BookRepoSQL:DeleteItem")
	defer func() { trace.Finish(tracer.FinishWithError(err)) }()

	db := r.writeDB
	if tx, ok := candishared.GetValueFromContext(ctx, candishared.ContextKeySQLTransaction).(*gorm.DB); ok {
		db = tx
	}
	err = r.setFilterBookItem(globalshared.SetSpanToGorm(ctx, db), filter).Delete(&shareddomain.BookItem{}).Error
	return
}

func (r *bookRepoSQL) setFilterBookItem(db *gorm.DB, filter *domain.FilterBookItem) *gorm.DB {

	if filter.ID != nil {
		db = db.Where("id = ?", *filter.ID)
	}

	for _, preload := range filter.Preloads {
		db = db.Preload(preload)
	}

	return db
}
